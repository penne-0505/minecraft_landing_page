# パフォーマンス問題の分析と改善提案

## 1. Tailwind CDNによるレンダリングブロックと大型CSSの配信

**問題概要:** 現在のページは`index.html`でTailwind CSSをCDN経由で読み込んでいます。CDN版Tailwindは**開発用の全ユーティリティを含む大容量のCSS**をクライアントで生成する方式であり、ページ表示時にレンダリングをブロックします。これにより初回描画が遅れ、**First Contentful Paint (FCP)** の遅延要因となっています。また不要なスタイルも含むため、**未使用CSSの割合**が大きく、Lighthouseレポートでも**「レンダリングを妨げるリソースの除外」**や**「未使用のCSSの削減」**として指摘されています。特にGoogleフォントCSSと合わせ、**推定117KiBものCSSが初期表示に未使用**と報告されています。

**Lighthouseスコアへの影響:** Tailwind CDNスクリプトはHTMLヘッダで実行されるためレンダリングをブロックし、FCPを押し下げます。実際レポートではFCPが**1.2秒**（スコア0.78）とやや遅く、また**Speed Index**（表示完了までの速度）も**4.0秒**と低スコア（0.1）でした。これはCSSの読み込み・適用待ちで描画が停滞したことの表れです。また**Largest Contentful Paint (LCP)** も**1.6秒**（スコア0.77）と、改善の余地があります。重いCSSはこれら描画指標のみならず、後述するJS実行遅延にも影響し得ます。

**該当ソース:** `index.html`でTailwindのスクリプト読み込み箇所が問題の発端です。またプロジェクトのTODOには、本番環境で**「cdn.tailwindcss.com」の使用をやめビルド済みCSSを読み込む**方針が記載されています。実際にTailwind CDN廃止のタスクでは「本番配信時の警告解消とパフォーマンス最適化のため、Tailwind CDNの利用をやめてビルド生成に切り替える」と明記されています。

**改善提案:** Tailwind CSSは**ビルド時に必要なスタイルだけを生成**する構成に変更します。具体的には:

- **Tailwindのローカルビルド導入:** PostCSSや公式CLIを用いてTailwindをプロジェクトに組み込み、`npm run build`時にpurge（使用クラス抽出）されたCSSを出力します。例えばTailwind公式のJITコンパイラをViteに統合することで、利用クラスのみを含むCSSを生成可能です。
- **CDNスクリプトの除去:** 上記に伴い、`index.html`から `<script src="https://cdn.tailwindcss.com">` を削除し、代わりに生成されたCSSファイルを\<link\>タグで読み込みます。
- **CSSファイルの最適化:** 生成CSSは不要スタイルを含まず、**圧縮（minify）**して配信します。Tailwind導入後はプロダクションCSSが**10KB以下**に収まる可能性があります（CDN版は圧縮後でも約300KBと報告されています）。

これらにより**レンダリングブロッキング時間が短縮**され、CSS経由のFCP遅延が解消します。実装にはTailwind CLIやViteのプラグイン（例: `@vitejs/plugin-react`経由でPostCSS連携）を利用すると良いでしょう。

**期待効果:** 不要CSSの除去とレンダリングブロック解消により、**FCP/LCPの短縮**および**Speed Indexの改善**が見込まれます。Tailwind CDN廃止により推定**200ms程度の描画遅延を短縮**できるとレポートも示しています。CSS容量削減はネットワーク負荷を減らし、初期描画完了を早めるでしょう。結果としてLighthouseパフォーマンススコア全体（特にFCP/Speed Index）が向上し、ユーザーにとっても体感表示速度の向上が期待できます。

## 2. JavaScriptバンドルの肥大化と未使用コードの読み込み

**問題概要:** 本プロジェクトは単一のReactアプリケーションとして実装されていますが、**ルーティングごとのコード分割 (Code Splitting) が行われていません**。`App.jsx`では全ページコンポーネントを一括で`import`しており、SPA起動時に不要なページのJSまで読み込んでいます。またアニメーションライブラリ（framer-motion）やアイコン集（lucide-react）、Google Analytics用スクリプトなど**大きな依存JS**も初期ロードに含まれています。その結果、**初期バンドルサイズが肥大化**し、パース・実行に時間がかかっています。Lighthouseの**「未使用のJavaScriptの削減」**監査では、初期ロードされた約185KBのJSのうち**60%以上（約113KB）が未使用**と指摘されています。加えて、GoogleタグマネージャのスクリプトやTailwind CDNスクリプトも未使用分を含め配信されており、合計で**約188KiBの削減余地**がある状態です。

**Lighthouseスコアへの影響:** 不要なJSを含む大きなバンドルは、**メインスレッドの処理を占有**して初期表示を阻害します。実際、Lighthouseレポートでは**Total Blocking Time (TBT)** が**1,340ミリ秒**と非常に大きく、ユーザー操作可能になるまでに**10.4秒**もかかっています。TBTの長さ（スコア0.02）やTime to Interactive（スコア0.03）の悪さは、大量のJS parsing/実行がレンダリング後も続いていることを示唆します。特にSpeed Indexにも影響し、レンダリングの途中で長いタスクが発生すると画面描画の進行が滞りスコア悪化に繋がります。上述の通りSpeed Indexが**0.1**と極端に低い原因の一つは、このJS処理の重さと考えられます。

**該当ソース:** `src/App.jsx` および各ページコンポーネント。`App.jsx`では`JoinLanding`, `Membership`, `Supporters`等をトップレベルで読み込んでいます。そのため、ユーザーが最初にランディングページを見る際にも、メンバーシップやサポートページ用のコードまでまとめてダウンロード・実行されています。また、`analytics.js`ではGA4やSentryの初期化コードが組み込まれており、環境変数によっては起動時に外部スクリプト（gtag.js約100KB）を非同期読み込みしています。framer-motionやlucide-reactのようなライブラリも各所でインポートされ、これらがバンドルサイズ増大に寄与しています。

**改善提案:** **JavaScriptの分割最適化と読み込み制御**を行います。

- **ルートレベルのCode Splitting:** Reactの`lazy`や`Suspense`を活用し、ルートごとにコードを分割します。例えば`Membership.jsx`や`Supporters.jsx`を動的インポートに変更し、ユーザーが該当ページに遷移した時のみ読み込むようにします。これにより初期バンドルから不要コードを除外でき、**未使用JS約113KB**相当を削減できます。Viteは動的`import()`により自動的にチャンクを分離するため、設定変更無しに効果を得られます。
- **ライブラリの必要最小化:** アニメーション表現に現在framer-motionを使用していますが、シンプルなフェードインやホバーエフェクトであればCSSトランジションや軽量なユーティリティで代替可能です。特に**初期表示領域（ヒーローセクション）**で用いるアニメーションは、可能ならCSSベースに置き換え、複雑な動きが必要な部分だけをframer-motion (動的ロードも検討) に委ねます。アイコンについても、lucide-react経由で複数アイコンをまとめてインポートしていますが、SVGを直接埋め込むか必要なものだけ個別importすることで負荷を減らせます（既に個別importされていますが、バンドルへの取り込み状況を確認します）。
- **不要コードの削除:** 使用していない機能フラグやデバッグ用コードがあればビルド時に除去します。たとえば`analytics.js`でSentry連携がコメントアウト状態ならば、本番ビルドでは該当コードをtree shakingで落とすか、環境変数で無効化して読み込みを発生させないようにします。
- **読み込みタイミングの調整:** 必須ではないスクリプトは初期描画後に遅延読み込みします。例えばAnalyticsのロードは、ページロード直後ではなく`load`イベント後やユーザーの初回操作後に行うことで、メインスレッド競合を防ぎます（現在もgtagは`async`で読み込んでいますが、更なる遅延も検討できます）。

これら改善には、Webpack/Viteのバンドル分析ツール（**Source Map Analyzer**等）を用いてサイズの大きいモジュールを特定し、集中的に対策することも有効です。React開発者ツールやPerformanceプロファイラで、初期ロード時の長時間タスクを計測し、どのスクリプトがブロッキング要因か分析すると良いでしょう。

**期待効果:** 初期JSの削減により**ページのインタラクティブ開始が大幅に短縮**されます。未使用コード188KiB削減の指摘通り、バンドルをスリム化すれば**TBTが1秒以上圧縮**され、Lighthouseの予測ではFCP/LCPも各150ms程度向上するとされています。実際、Code Splittingと不要JS除去によってTBTは**1339ms→数百ms以下**に、Time to Interactiveも劇的に改善し**ユーザーは約10秒待たずに操作可能**になる見込みです。また並行してSpeed Indexも改善し、**初期表示の体感速度向上**に繋がるでしょう。

## 3. 画像の最適化不足（サイズ過剰・遅延読み込みの欠如）

**問題概要:** ヒーロー画像やギャラリー画像にWebP形式を採用するなど工夫されていますが、**実際の配信画像サイズが表示に対して過大**である点が指摘されます。現在の実装では、レスポンシブ対応の`srcset`はあるものの各画像につき**実寸大の1種類のみ**を指定しており、小画面向けの縮小版が用意されていません。例えばギャラリーのサムネイルはモバイル表示で幅数百ピクセル程度ですが、数千ピクセル幅のフル解像度画像（数百KB）がそのままロードされています。このためLighthouseの**「適切なサイズの画像」**監査では、**約1.3MBもの容量削減余地**があると報告されています。実際例として、幅309px程度で表示される画像に対し2160w（約200KB超）の画像が供給され、**97--98%が無駄**になっているケースが多数ありました。また、ヒーローセクションでは3枚の画像（メイン＋左右飾り）すべて`loading="eager"`で読み込んでおり、**オフスクリーン画像の遅延読み込み**も最適とは言えません。ギャラリー画像もデフォルトでは遅延指定がなく、初期ロード時に全て読み込まれている可能性があります。

**Lighthouseスコアへの影響:** 過大な画像のダウンロードは**ネットワーク帯域を圧迫**し、他の重要リソースの処理を遅らせます。ただしFCP/LCPには主に**最大要素の表示タイミング**が反映されるため、現在LCP(1.6秒)自体は許容範囲でした。しかしSpeed IndexやTBTには間接的に影響します。大量の画像を初期に読み込むことでメインスレッドが画像デコード処理に時間を使い、**Speed Indexの遅延（4.0秒）**や場合によっては**TBT増大**を招きます。また**Largest Contentful Paint**候補が画像の場合、その最適化不足はLCPスコア悪化要因になります。実際Lighthouseでも「適切なサイズの画像」の項目で警告が出ており、スコア改善のボトルネックの一つです。

**該当ソース:** 画像周りの実装は`src/data/lpImages.js`に定義され、`JoinLanding.jsx`や`Membership.jsx`で使用されています。設計ドキュメントによれば、現在は各画像について**単一のオリジナルWebPファイルのみを**`srcset`**に指定**しているとのことです。例えばギャラリー画像`column1-2.webp`などは`srcset`に1エントリ (2160w) を持つだけで、内部的には以下のように指定されています（擬似コード）:

```html
<img 
  srcSet="column-1-2.webp 2160w" 
  sizes="(max-width: 768px) 100vw, 33vw" 
  width={2160} height={???} … />
```

このため`sizes`によって表示サイズ自体は33vw程度と計算されても、ブラウザは**利用可能な唯一の大画像を取得**するしかなく、結果的にオーバースペックなデータをダウンロードしています。

また、`JoinLanding.jsx`ではヒーロー画像3枚すべてに`loading="eager"`が設定されています。メイン画像（LCP想定）には適切ですが、視認性の低い左右の飾り画像までeagerになっている点は改善の余地があります。同様に、`MemoryLane`セクションの複数画像もコード上`loading`指定がなく、デフォルトeager（直ちに読み込み）となっています。

**改善提案:** **画像のレスポンシブ配信と遅延読み込み**を徹底します。

- **複数解像度の用意:** 各画像について、表示サイズに応じた複数の解像度バリエーションを生成し、`srcset`に追加します。プロジェクト内ガイドでは640px/1024px/1600px版の生成が推奨されています。例えばヒーロー画像なら`1600w, 1024w, 640w`のエントリを持たせ、ギャラリー画像も大きなモニター用に最大サイズを用意しつつ、小画面用に縮小版を加えます。ImageMagickを用いる場合、以下のコマンドで品質82%のWebPを各サイズ生成できます（ドキュメント記載の例）:

```bash
magick input.jpg -strip -quality 82 output.webp
magick input.jpg -strip -quality 82 -resize 640x>  output-640.webp
magick input.jpg -strip -quality 82 -resize 1024x> output-1024.webp
magick input.jpg -strip -quality 82 -resize 1600x> output-1600.webp
```

生成した画像をリポジトリの`src/assets/images/...`に配置し、`lpImages.js`の対応箇所で`srcset`を拡張します。これによりブラウザは画面サイズに適したより小さいファイルを選択でき、無駄な通信を防げます。Lighthouseの指摘では**最大で1.3MB超の節約**になると見積もられており、この対策はSpeed Indexと全体スコアの向上に直結します。

- **適切な**`loading`**戦略:** 初期表示に不要な画像は遅延読み込み (`loading="lazy"`) を指定します。具体的には、**折り返し以降の全画像**（ギャラリー・フッター等）は`lazy`とし、ユーザーがスクロールして近づいた時点で読み込むようにします。これにより初期ロード時のネットワーク・CPU負荷を軽減可能です。ヒーローセクションではメイン画像のみ`eager/high`のまま維持し（LCPを優先）、左右の飾り画像は`lazy`または低優先度で後回しにします。実装上は、Reactで条件的に`loading`属性を与えるか、もしくは飾り画像をバックグラウンドCSSなどで表現する方法も考えられます。

- **画像圧縮の確認:** 現状WebP(品質82)を採用しており、**「最新フォーマット」「適切なエンコード」**の項目は合格しています。引き続きWebPや将来のAVIFを使い、必要に応じて圧縮率を調整します（ただし過度な圧縮は画質低下を招くため、現状維持で問題ありません）。

- **キャッシュ活用:** Cloudflare Pages配信であれば静的アセットは自動でキャッシュされますが、可能であれば`<img>`タグに`decoding="async"`や`fetchpriority`属性を指定する現状の工夫も維持します。ヒーロー画像には既に`fetchPriority="high"`が付与されており、ブラウザが優先的に取得するようになっています。この指定は有効なので、引き続きLCP想定画像に適用してください。

**期待効果:** 適切なサイズの画像提供により、**無駄なデータ転送が削減**されページ全体の読み込みが速くなります。Lighthouseレポートでは本対策で**最大70ms程度の直接的なLCP短縮**が見込まれるほか、何よりSpeed Index改善への寄与が大きいでしょう。実装後はギャラリー画像の大部分（平均90%以上）が削減されるため、他のリソース取得がスムーズになり、体感表示も軽快になります。また遅延読み込みによって**初期ロード時の画像リソース競合が減り、FCP/LCPの安定化**にも繋がります。以上により、パフォーマンススコア全般（特にSpeed Index）が向上し、ユーザーにストレスの少ない閲覧体験を提供できるでしょう。

## 4. ウェブフォントの読み込み最適化

**問題概要:** 本サイトでは**M PLUS Rounded 1c**や**Outfit**といったカスタムフォントを使用していますが、その読み込み手法に改善余地があります。現在、Google FontsのCSSを`<style>@import</style>`で読み込んでおり、複数フォントファミリ（Outfitに加えCaveatやZen Kurenaidoなど）を一括指定しています。Lighthouseの解析によれば、このリクエストで取得されたフォントCSSは約120KBに及び、その**100%が初期ビューで未使用**となっていました。これは、読み込んだフォントのうち実際には使われていないものが含まれているか、または読み込みタイミングの問題で初回描画に間に合わず未適用とみなされた可能性を示します。さらに、@importによるCSS読み込みはレンダリングをブロックしうる点も懸念事項です（リンクタグに比べ遅延が生じやすい）。

**Lighthouseスコアへの影響:** フォント読み込み自体はFCP/LCPへ直接影響しにくいものの、**未使用CSSの伝送**としてパフォーマンスロスになります。実際**「未使用のCSSルールの削減」**で最大約117KiBの節約余地が指摘され（スコア0）、不要なフォントを除去すればわずかながら**FCP/LCPが50ms程度改善**すると試算されています。また、@import利用によりフォントCSS取得がワンテンポ遅れると、テキストが一瞬デフォルトフォントで表示された後に置き換わるFOIT/FOUT現象が発生する可能性があります。もっとも本実装では`display=swap`を指定しているため（フォントCSS内）、テキスト非表示は避けられていますが、フォント切り替えによる視覚的なレイアウトシフトが起こり得ます（もっともCLSスコアは0.001と極小でした）。

**該当ソース:** フォント関連コードは各ページのトップレベル`<style>`タグに埋め込まれています。例えばメンバーシップページでは以下のようにインポートしています（Thanks.jsxでも類似の記述）:

```html
<style>
  @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&family=Outfit:wght@500;700;900&display=swap');
  .font-display { font-family: 'Outfit', sans-serif; }
</style>
```

ここで`family=`パラメータに指定されていない**Caveat**や**Zen Kurenaido**もLighthouseレポート上に検出されていることから、過去の実装で別のフォントを読み込んだ名残や、別ページで追加インポートしている可能性があります。いずれにせよ、現在のデザインで不使用のフォントをリクエストしている点が無駄と言えます。

**改善提案:** **フォントの読み込みを軽量化・適切化**します。

- **不要フォントの除外:** 現在リクエストに含まれている *Caveat*, *Zen Kurenaido* など、本サイトで使っていないフォントはGoogle FontsのURLから削除します。読み込みを*M PLUS Rounded 1c*と*Outfit*のみに絞ることで、フォントCSSのサイズ削減（120KB→数十KB程度）とフォントファイルのダウンロード件数減少が見込めます。フォント選定が変更になった場合でも、使わなくなったファミリは都度除去し、リクエストを最適化してください。

- **読み込み方法の改善:** \@importではなく、可能なら`<link rel="stylesheet">`**によるプリロード**を検討します。例えば、`<link href="https://fonts.googleapis.com/css2?...&display=swap" rel="stylesheet" media="print" onload="this.media='all'">`のような記法で非同期にロードし、オンロード時にメディアを適用する手法があります。これによりレンダリングブロックを回避できます。また`<link rel="preconnect" href="https://fonts.gstatic.com">`を\<head\>に入れておくと、フォントファイル取得のDNS/TLSを事前確立でき、若干の高速化になります。

- **フォントサブセットの活用:** 特にM PLUS Rounded 1cは日本語を含む大規模フォントです。Google Fontsはデフォルトで必要な文字サブセットのみ配信しますが（おそらくLatinやJPサブセット）、必要最小の字形セットになっているか確認します。例えば数字や記号のみ別フォントにするといった工夫でデータ量削減も考えられます（ただし可読性とのトレードオフなので無理のない範囲で）。

- **ローカルフォント/キャッシュの利用:** ユーザ環境に同等フォントがある場合にフォールバックできるよう、CSSの`font-family`指定には汎用フォントも入れてあります（sans-serif等）。加えて、頻繁にアクセスされるならば自前でフォントをホスティングし、長期キャッシュする手もあります。Pages機能でフォントファイルを配信し、CSSから参照すればGoogleへの追加リクエストを削減できます。ただし初期導入コストがあるため、まずは上記のようにGoogle Fonts経由でも無駄を省く運用が現実的です。

**期待効果:** 不要フォントを除けば、その分**CSS 120KBが丸ごと削減**されます。これにより**僅かながらFCP/LCPの改善**（数十ms単位）が期待でき、何より無駄な通信が減ることで他リソースの取得が効率化します。またレンダリング直後のフォント切り替わりによる視覚変化も抑制でき、CLS（現状ほぼ0ですが）の安定に寄与します。フォントはユーザー体験上も重要なので、最適化によって**テキスト表示のスムーズさ**が向上し、パフォーマンス指標のみならずUX全般の品質向上につながるでしょう。

---

以上の改善提案により、該当ページのパフォーマンス指標は総合的に改善される見込みです。**レンダリングブロック解消**・**JS処理負荷軽減**・**画像伝送量削減**・**フォント最適化**というアプローチで、LighthouseスコアのボトルネックだったFCP/LCP/Speed Index（および関連するTBT/TTI）を大きく引き上げられるでしょう。実装後は再度Lighthouse監査を行い、指標改善幅を確認しつつ微調整をおすすめします。
